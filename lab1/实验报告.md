## Lab 1 图像几何变换

PB22111695 蔡孟辛

### 1 图像的平移

原图像 (x0, y0) ，经过水平平移量为 tx，垂直平移量为 ty，平移后坐标为 (x1, y1)，满足：
$$
\begin{cases} x1 = x0 + tx\\y1 = y0 + ty\end{cases}
$$
矩阵表示如下：
$$
\begin{bmatrix}x1\\y1\\1\end{bmatrix}=\begin{bmatrix}1&0&tx\\0&1&y1\\0&0&1\end{bmatrix}\begin{bmatrix}x0\\y0\\1\end{bmatrix}
$$
代码表示如下：

（不使用库函数）使用for循环，用矩阵对每个像素点进行。其中 `size(img)` 返回的是行数 `rows`，列数 `cols` 和RGB通道 `channels` 。所以原图像矩阵 `[x0; y0; 1]` 在循环中表示为 `[j; i; 1]`，在矩阵乘法后得到 `p=[x1 y1 1]` ，用 x 和 y 提取矩阵p 中第一行第一列与第二行第一列的数据即为所求的平移后的坐标。最后赋值即可。


```matlab
% create translation matrix
TMatrix = [1 0 tx;
           0 1 ty; 
           0 0 1];

% translation
for i = 1 : rows
    for j = 1 : cols
        % translate every pixel
        p = TMatrix * [j; i; 1];
        x = p(1,1);
        y = p(2,1);
        % copy new img
        if((x >= 1) && (x <= cols) && (y >= 1) && (y <= rows))
            for k = 1 : channels
                tsimg(y, x, k) = img(i, j, k);
            end
        end
    end
end
```

<div STYLE="page-break-after: always;"></div>

实验结果为：

![image-20250417154847258](E:\cylia\大三\数字图像\lab1\translation.png)



### 2 图像的旋转

本次实验中需要绕图像中心点旋转。故先求出中心点坐标：

```matlab
% image center
cx = cols / 2;
cy = rows / 2;
```

绕点 `(a,b)` 的旋转矩阵如下：
$$
\begin{bmatrix}x1\\y1\\1\end{bmatrix}=\begin{bmatrix}1&0&a\\0&1&b\\0&0&1\end{bmatrix}\begin{bmatrix}cos(\theta)&-sin(\theta)&0\\sin(\theta)&cos(\theta)&0\\0&0&1\end{bmatrix}\begin{bmatrix}1&0&-a\\0&1&-b\\0&0&1\end{bmatrix}\begin{bmatrix}x0\\y0\\1\end{bmatrix}
$$
代码中表示为：

```matlab
% Rotation Matrix
RMatrix = [cos(thetarad), -sin(thetarad), 0;
           sin(thetarad), cos(thetarad),  0;
           0,             0,              1];

% 绕中心点旋转的运算矩阵
TMatrix = [1 0 cx;
           0 1 cy; 
           0 0 1];
TMatrix_T = [1 0 -cx;
             0 1 -cy; 
             0 0  1];
opMatrix = TMatrix * RMatrix * TMatrix_T;
```



#### 2.1 最近邻法

​		需要使用反变换，对于生成图像的每一个新的像素点，通过乘以矩阵的逆，找到旋转之前的点最近的整数点，得到像素值。

```
nnimg = zeros(rows, cols, channels, 'uint8');
for i= 1 : cols
    for j = 1 : rows
        % translate every pixel
        p = inv(opMatrix) * [i; j; 1] ;
        x = fix(p(1,1));
        y = fix(p(2,1));
        if((x >= 1) && (x <= cols) && (y >= 1) && (y <= rows))
            for k = 1 : channels
                % 该点的像素值
                nnimg(j, i, k) = img(y, x, k);
            end
        end
    end
end
```



#### 2.2 双线性插值法

​		同理，通过乘以旋转矩阵的逆的方式找到原像素点，在通过原像素点的左下，左上，右上，右下4个整数点，通过双线性插值法计算像素值。

![image-20250524203438541](E:\cylia\大三\数字图像\lab1\image-20250524203438541.png)

计算公式如下：
$$
f(R_1)\approx\frac{x_2-x}{x_2-x_1}f(Q_{11})+\frac{x-x1}{x_2-x_1}f(Q_{21})\\
f(R_2)\approx\frac{x_2-x}{x_2-x_1}f(Q_{12})+\frac{x-x1}{x_2-x_1}f(Q_{22})\\
f(P)\approx\frac{y_2-y}{y_2-y_1}f(R_1)+\frac{y-y1}{y_2-y_1}f(P_2)
$$


又因为$x_2-x_1 = y_2-y_1 = 1$，故原公式可化简为：
$$
f(P)\approx(x_2-x)\times(y_2-y)f(Q_{11})+(x-x_1)\times(y_2-y)f(Q_{21})+\\
(x_2-x)\times(y-y_1)f(Q_{12})+(x-x_1)\times(y-y_1)f(Q_{22})
$$
代码中通过 if 语句处理 x，y 为整数的情况，防止旋转时出现白边。最终代码如下：

``````matlab
bimg = zeros(rows, cols, channels, 'uint8');
for i= 1 : cols
    for j = 1 : rows
        p = inv(opMatrix) * [i; j; 1];
        x = p(1,1);
        y = p(2,1);
        if ((x >= 1) && (x <= cols) && (y >= 1) && (y <= rows))
            % 4 point (x1, y2) (x2, y2) 
            %         (x1, y1) (x2, y1）
            x1 = floor(x);
            x2 = ceil(x);
            y1 = floor(y);
            y2 = ceil(y);
            for k = 1 : channels
                % x, y 为整数
                if( x == x1 && y == y1 )
                    bimg(j, i, k) = img(y, x, k);
                % x 为整数
                elseif (x == x1) 
                    p1_val = (y2 - y) * img(y1, x1, k);
                    p3_val = (y - y1) * img(y2, x1, k);
                    bimg(j, i, k) = p1_val + p3_val;
                % y 为整数
                elseif (y == y1) 
                    p1_val = (x2 - x) * img(y1, x1, k);
                    p2_val = (x - x1) * img(y1, x2, k);
                    bimg(j, i, k) = p1_val + p2_val;
                % 正常情况
                else
                    p1_val = (x2 - x) * (y2 - y) * img(y1, x1, k);
                    p2_val = (x - x1) * (y2 - y) * img(y1, x2, k);
                    p3_val = (x2 - x) * (y - y1) * img(y2, x1, k);
                    p4_val = (x - x1) * (y - y1) * img(y2, x2, k);
                    bimg(j, i, k) = p1_val + p2_val + p3_val + p4_val;
                end
            end
        end
    end
end
``````

<div STYLE="page-break-after: always;"></div>

#### 2.3 结果图像

旋转角度 $\theta = 60^\circ$： 

![image-20250524194328347](E:\cylia\大三\数字图像\lab1\Rotation.png)

可以发现，对比起来，最近邻法得到的旋转图像较为粗糙，双线性插值法得到的图像则较为平滑。



### 3 图像的缩放

原图中，点(*x*0 , *y*0 ) 对应于新图中的点(*x*1 , *y*1 ) 的转换矩阵为：
$$
\begin{bmatrix}x1\\y1\\1\end{bmatrix}=\begin{bmatrix}c&0&0\\0&d&0\\0&0&1\end{bmatrix}\begin{bmatrix}x0\\y0\\1\end{bmatrix}
$$
代码表示如下：

``````matlab
SMatrix = [c, 0, 0;
           0, d, 0;
           0, 0, 1];
``````

之后的最近邻法和双线性插值法和旋转所使用的代码基本一致，仅有旋转矩阵改变为缩放矩阵。

代码略。

<div STYLE="page-break-after: always;"></div>

所得图像如下（c = 0.6，d = 2）：

![image-20250524201113150](E:\cylia\大三\数字图像\lab1\Scaling.png)



### 4 图像几何失真校正

#### 4.1 公式推导

选取原图与需矫正图像的四个角，共8个点作为基准点。

``````matlab
[x, y] = ginput(8);
u1 = x(1); v1 = y(1); x1 = x(2); y1 = y(2);
u2 = x(3); v2 = y(3); x2 = x(4); y2 = y(4);
u3 = x(5); v3 = y(5); x3 = x(6); y3 = y(6);
u4 = x(7); v4 = y(7); x4 = x(8); y4 = y(8);
``````

假设投影变换矩阵为 M，则有：
$$
\begin{bmatrix}u\\v\\1\end{bmatrix}=M*\begin{bmatrix}x\\y\\1\end{bmatrix}
$$
对于每一对控制点 (x,y) 和 (u,v)，根据投影变换公式：
$$
u = (m_{11}x + m_{12}y + m_{13}) / (m_{31}x + m_{32}y + 1)\\
v = (m_{21}x + m_{22}y + m_{13}) / (m_{31}x + m_{32}y + 1)
$$
消除分母，改写为：
$$
(m_{31}x + m_{32}y + 1)u = m_{11}x + m_{12}y + m_{13}\\
(m_{31}x + m_{32}y + 1)v = m_{21}x + m_{22}y + m_{13}
$$


整理得到：
$$
u = m_{11}x + m_{12}y + m_{13} - m_{31}xu - m_{32}yu \\
v = m_{21}x + m_{22}y + m_{23} - m_{31}xv - m_{32}yv
$$
每个控制点会生成两行（第一个点）：
$$
\begin{bmatrix}
x_1 & y_1 & 1 & 0 & 0 & 0 & -x_1u_1 & -y_1u_1\\
0 & 0 & 0 & x_1 & y_1 & 1 & -x_1v_1 & -y_1v_1
\end{bmatrix}
$$
4 对控制点生成 8×8 的矩阵 A 如下：
$$
A=\begin{bmatrix}
x_1 & y_1 & 1 & 0 & 0 & 0 & -x_1u_1 & -y_1u_1\\
0 & 0 & 0 & x_1 & y_1 & 1 & -x_1v_1 & -y_1v_1\\
x_2 & y_2 & 1 & 0 & 0 & 0 & -x_2u_2 & -y_2u_2\\
0 & 0 & 0 & x_2 & y_2 & 1 & -x_2v_2 & -y_2v_2\\
x_3 & y_3 & 1 & 0 & 0 & 0 & -x_3u_3 & -y_3u_3\\
0 & 0 & 0 & x_3 & y_3 & 1 & -x_3v_3 & -y_3v_3\\
x_4 & y_4 & 1 & 0 & 0 & 0 & -x_4u_4 & -y_4u_4\\
0 & 0 & 0 & x_4 & y_4 & 1 & -x_4v_4 & -y_4v_4
\end{bmatrix}
$$
矩阵B包含所有u和v：
$$
B=\begin{bmatrix}
u_1\\v_1\\u_2\\v_2\\u_3\\v_3\\u_4\\v_4
\end{bmatrix}
$$
由之前得到的方程，易知：
$$
A*M=B
$$
故：
$$
M = A^{-1} * B
$$
得到的投影变化矩阵如下：
$$
\begin{bmatrix}
m_{11} & m_{21} & m_{31}\\
m_{41} & m_{51} & m_{61}\\
m_{71} & m_{81} & 1
\end{bmatrix}
$$
最后，计算齐次坐标的归一化因子，并反变换坐标即可得到结果。



#### 4.2 完整代码

``````matlab
A=[x1 y1 1 0  0  0 -x1*u1 -y1*u1;
   0  0  0 x1 y1 1 -x1*v1 -y1*v1;
   x2 y2 1 0  0  0 -x2*u2 -y2*u2;
   0  0  0 x2 y2 1 -x2*v2 -y2*v2;
   x3 y3 1 0  0  0 -x3*u3 -y3*u3;
   0  0  0 x3 y3 1 -x3*v3 -y3*v3;
   x4 y4 1 0  0  0 -x4*u4 -y4*u4;
   0  0  0 x4 y4 1 -x4*v4 -y4*v4];

B=[u1; v1; u2; v2; u3; v3; u4; v4];

M = inv(A) * B;

pMatrix = [M(1,1) M(2,1) M(3,1); 
          M(4,1) M(5,1) M(6,1);
          M(7,1) M(8,1) 1    ];

invM = inv(pMatrix);

dimg = zeros(rows1, cols1, channels1, 'uint8');
for i= 1 : rows1
    for j = 1 : cols1
        % 计算 齐次坐标的归一化因子 w 用于从目标图像映射回失真图像
        w = 1 / ( invM(3,1) * j + invM(3,2) * i + 1);
        
        % 反变换
		p =   invM * [w * j; w * i; w];

		x = fix(p(1, 1));
		y = fix(p(2, 1));
        
		if((x >= 1) && (x <= cols2) && (y >= 1) && (y <= rows2))
			for k = 1 : channels2
				dimg(i, j, k) = img2(y, x, k);
			end
		end
    end
end
``````



#### 4.3 运算结果图像

（选点时无法精准定位，校正图像和原图略有区别）

![decorrection.png](E:\cylia\大三\数字图像\lab1\decorrection.png)


<div STYLE="page-break-after: always;"></div>

## Lab 2 图像点处理增强

### 1 灰度的线性变换

灰度变换方程为：
$$
D_B = F(D_A)=f_A\cdot D_A + f_B
$$
其中参数 $f_A$ 为线性函数的斜率，$f_B$为线性函数的在 y 轴的截距，$D_A$表示输入图像的灰度，$D_B$表示输出图像的灰度。

代码如下：

```matlab
fA = input("please input f_A: "); % 斜率
fB = input("please input f_B: "); % 截距

for i = 1 : rows
    for j = 1 : cols
        limg(i,j) = img(i,j) * fA + fB;
    end
end
```

运算结果图像如下（$f_A = 0.5$，$f_B=5$）：

![lab2_1_linear.png](E:\cylia\大三\数字图像\lab2\lab2_1_linear.png)



### 2 灰度拉伸

灰度拉伸和灰度线性变换相似。不同之处在于它是分段线性变换。表达式如下：
$$
f(x) = 
\begin{cases} 
\frac{y_1}{x_1} x & \text{if } x < x_1 \\
\frac{y_2 - y_1}{x_2 - x_1}(x - x_1) + y_1 & \text{if } x_1 \leq x \leq x_2 \\
\frac{255 - y_2}{255 - x_2}(x - x_2) + y_2 & \text{if } x > x_2
\end{cases}
$$
其中，$(x_1 , y_1 ) $ 和 $(x_2 , y_2 ) $ 是分段函数的转折点。

代码如下：

``````matlab
for i = 1:rows
    for j = 1:cols
        x = img(i, j);
        if(x < x1)
            epimg(i, j) = y1 / x1 * x;
        else
            if(x <= x2)
                epimg(i, j) = (y2 - y1)/(x2 - x1) * (x - x1) + y1;
            else
                epimg(i, j) = (255 - y2)/(255 - x2) * (x - x2) + y2;
            end
        end
    end
end
``````

图像如下（x1= 0.5，y1=30，x2=3，y2=49）：

![lab2_2_expand](E:\cylia\大三\数字图像\lab2\lab2_2_expand.png)

<div STYLE="page-break-after: always;"></div>

### 3 灰度直方图

调用函数histogram：

``````matlab
histogram(img, 'BinLimits', [min, max]);
``````

结果图像（min = 50， max = 150）：

![lab2_3_grayhistogram](E:\cylia\大三\数字图像\lab2\lab2_3_grayhistogram.png)



### 4 直方图均衡

1) 显示一幅图像 pout.bmp 的直方图；

   ``````matla
   img = imread('pout.bmp');
   histogram(img);
   ``````

2) 用直方图均衡对图像 pout.bmp 进行增强；

   ``````matl
   ans1 = histeq(img);
   ``````

3) 显示增强后的图像及其直方图。

   ``````matl
   histogram(ans1);
   ``````

4) 用原始图像 pout.bmp 进行直方图规定化处理，将直方图规定化为高斯分布；

   ``````matlab
   ans2 = histeq(img, normpdf((0:1:255),60,10));
   ``````

5) 显示规定化后的图像及其直方图。

   ``````matl
   imshow(ans2);
   histogram(ans2);
   ``````

结果图像如下：

![lab2_4_graybalance](E:\cylia\大三\数字图像\lab2\lab2_4_graybalance.png)



<div STYLE="page-break-after: always;"></div>

## Lab 3 图像空间域滤波增强

### 1 用均值滤波器去除图像中的噪声（3x3 窗口）

用原始图像p 分别加产生的 3%椒盐噪声、高斯噪声、随机噪声合成有噪声的图像。

``````matlab
% 3% 椒盐噪声
pepper = imnoise(img, 'salt & pepper', 0.03);
% 高斯噪声
gaussian = imnoise(img,'gaussian');
% 随机噪声
[row, cols] = size(img);
random = img;
for i = 1:row
    for j = 1:cols
        if(pepper(i,j) ~= img(i,j))
            random(i,j) = uint8(rand() * 255);
        end
    end
end
``````

用均值滤波器去除图像中的噪声（3x3窗口）:

``````matlab
fpepper = imfilter(pepper, fspecial("average",3));
fgaussian = imfilter(gaussian, fspecial("average",3));
frandom = imfilter(random, fspecial("average",3));
``````

<div STYLE="page-break-after: always;"></div>

结果图像：

![lab3_1](E:\cylia\大三\数字图像\lab3\lab3_1.png)



### 2 超限邻域平均法

数学原理：

$$
g(i,j)=\begin{cases}
\frac{1}{N\times N}\sum_{(x,y)\in A}f(x,y), & \left|f(i,j)-\frac{1}{N\times N}\sum_{(x,y)\in A}f(x,y)\right|>T \\
f(i,j), & \text{其它}
\end{cases}
$$


代码实现：调用函数 out_aver（）

``````matlab
out_pepper = out_aver(pepper, threshold);
out_gaussian = out_aver(gaussian, threshold);
out_random = out_aver(random, threshold);
``````

<div STYLE="page-break-after: always;"></div>

结果图像（阈值=50）：

![image-20250524235708931](E:\cylia\大三\数字图像\lab3\lab3_2.png)



### 3 中值滤波器

数学原理:

$$f(x_0, y_0) = \text{Med}\{f(x, y) \mid x \in [x_0 - N, x_0 + N], y \in [y_0 - N, y_0 + N]\}$$

代码实现：调用 medfilt2() 函数

``````matlab
med_pepper = medfilt2(pepper);
med_gaussian = medfilt2(gaussian);
med_random = medfilt2(random);
``````

<div STYLE="page-break-after: always;"></div>

结果图像：

![lab3_3](E:\cylia\大三\数字图像\lab3\lab3_3.png)



### 4 超限中值滤波器

原理：当某个像素的灰度值超过窗口中像素灰度值排序中间的那个值，且达到一定水平时，则判断该点为噪声，用灰度值排序中间的那个值来代替；否则还是保持原来的灰度值。

代码实现：

``````matlab
outmed_pepper = out_med(pepper, threshold);
outmed_gaussian = out_med(gaussian, threshold);
outmed_random = out_med(random, threshold);

function [out] = out_med(in, threshold)
    out = in;
    [row, cols] = size(out);
    for i = 2 : (row - 1)
        for j = 2 : (cols - 1)
            % 计算中值
            window = in(i-1 : i+1, j-1 : j+1);
            med_value = median(window(:));
            % 判断是否超越均值
            if(abs(double(in(i,j)) - double(med_value)) > threshold)
                out(i,j) = med_value;
            end
        end
    end
end
``````

<div STYLE="page-break-after: always;"></div>

结果图像（threshold=50）：

![lab3_4](E:\cylia\大三\数字图像\lab3\lab3_4.png)



### 5 四种处理方法的结果与原图比较

1. **均值滤波器**：
   - 均值滤波器是最简单的线性滤波器之一，它通过将一个像素点的灰度值替换为其邻域内所有像素点灰度值的平均值来平滑图像。
   - 优点：简单易实现，对高斯噪声有较好的抑制效果。
   - 缺点：会使图像变得模糊，尤其是边缘部分。
2. **超限邻域平均法**：
   - 这是一种改进的均值滤波器，根据像素与其邻域的差异性来决定是否进行平均操作。如果某像素与它的邻域平均值之差超过了一定阈值，则认为该像素是噪声，对其进行平均处理；否则保留原像素值。
   - 优点：比普通均值滤波器更好地保护了图像的细节和边缘信息。
   - 缺点：需要合理设定阈值，算法复杂度相对较高。
3. **中值滤波器**：
   - 中值滤波器是一种非线性的滤波器，通过选择邻域内的中值作为当前像素的新值来去除噪声。特别适用于椒盐噪声的去除。
   - 优点：有效去除脉冲噪声（如椒盐噪声），同时较好地保持了图像的边缘信息。
   - 缺点：对于复杂的噪声环境可能不是最佳选择，且处理速度相对较慢。
4. **超限中值滤波器**：
   - 超限中值滤波器结合了中值滤波器的优点，并引入了类似于超限邻域平均法的思想。即在某些条件下直接使用中值滤波的结果，而在其他情况下则使用原始像素值或其他策略。
   - 优点：能够在保持中值滤波器优势的同时，进一步减少对图像细节的影响。
   - 缺点：算法设计较为复杂，参数调整要求更高。



### 6 边缘检测

边缘检测主要有以下几种常用的算子：

1. **Roberts 算子**

   由下式给出：

   $$\mathbf{G}[F(x,y)] \approx [F(x,y) - F(x+1, y+1)] + [F(x+1, y) - F(x, y+1)]$$

   其中 $F(x,y)$ 是具有整数像素坐标的输入图像。

2. **Sobel 算子**

   图像中的每个点都用下面的两个模板做卷积，一个对通常的垂直边缘响应最大，另一个对水平边缘响应最大，两个卷积的最大值作为该点的输出位。

   | -1 | -2 | -1 | 
   |----|----|----| 
   | 0  | 0  | 0  | 
   | 1  | 2  | 1  | 

   | -1   | 0    | 1    |
   | ---- | ---- | ---- |
   | -2   | 0    | 2    |
   | -1   | 0    | 1    |

3. **Prewitt 算子**

   下面的两个模板形成了 Prewitt 算子，和使用 Sobel 算子的方法一样。
   | -1 | -1 | -1 | 
   |----|----|----| 
   | 0  | 0  | 0  | 
   | 1  | 1  | 1  | 

   | 1   | 0    | -1    |
   | ---- | ---- | ---- |
   | 1   | 0    | -1    |
   | 1   | 0    | -1    |

4. **拉普拉斯算子**

   $\nabla^2 f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} = f(i-1, j) + f(i+1, j) + f(i, j+1) + f(i, j-1) - 4f(i, j)$

   分别用模板：

   $\begin{bmatrix} 0 & 1 & 0 \\ 1 & -4 & 1 \\ 0 & 1 & 0 \end{bmatrix}$ 和 $\begin{bmatrix} -1 & -1 & -1 \\ -1 & 8 & -1 \\ -1 & -1 & -1 \end{bmatrix}$进行边缘检测。

5. **Canny 算子**

   ①用高斯滤波器平滑图像；

   ②用一阶偏导的有限差分来计算梯度的幅值和方向；

   ③对梯度幅值进行非极大值抑制；

   ④用双阈值算法检测和连接边缘。

代码实现：

```matlab
% Roberts 算子
Roberts = edge(img,"roberts");
% Sobel 算子
Sobel = edge(img,"sobel");
% Prewitt 算子
Prewitt = edge(img,"prewitt");
% 拉普拉斯算子
Laplacian1 = imfilter(img, fspecial("laplacian",0)); % 使用fspecial进行边缘检测
Laplacian2 = imfilter(img, [-1 -1 -1;-1 8 -1; -1 -1 -1]); % 边缘可视化
% Canny 算子
Canny = edge(img,"canny");
```

结果图像1（blood.bmp）:

![lab3_6_1](E:\cylia\大三\数字图像\lab3\lab3_6_1.png)

<div STYLE="page-break-after: always;"></div>

结果图像2（lena.bmp）：

![lab3_6_2](E:\cylia\大三\数字图像\lab3\lab3_6_2.png)

<div STYLE="page-break-after: always;"></div>

## Lab4 图像变换及频域滤波增强

### 1 Fourier 变换

用 Fourier 变换算法，对 rect1.bmp 和 rect2.bmp 图像作二维 Fourier 变换；

```matlab
% Fourier 变换
F1 = fft2(img1);
F2 = fft2(img2);
```

并显示其频谱。要求对幅度作变换（由于高、低频幅度相差很大），将低频移到中心点。

```matlab
% fftshift 把低频部分移动到图像中心
F1_shift = fftshift(F1);
F2_shift = fftshift(F2);
% abs 提取幅度信息 log(... + 1) 增强对比度
F1_scale = log(abs(F1_shift+1));
F2_scale = log(abs(F2_shift+1));
```

结果图像：

![lab4_1](E:\cylia\大三\数字图像\lab4\lab4_1.png)



### 2 Fourier 反变换

#### 2.1 用 Fourier 系数的幅度进行 Fourier 反变换

```matlab
% 取幅度进行逆变换
IF1 = uint8(ifft2(abs(F1)));
IF2 = uint8(ifft2(abs(F2)));
```

#### 2.2 用 Fourier 系数的相位进行 Fourier 反变换

```matlab
% 相位逆变换
% 取相位
F1_angle = angle(F1);
F2_angle = angle(F2);

% 逆变换 exp(1i * 相位): 复数频谱; 10000: 频率分量的幅度
IF1_angle = uint8(abs(ifft2(10000 * exp(1i * F1_angle))));
IF2_angle = uint8(abs(ifft2(10000 * exp(1i * F2_angle))));
```

#### 2.3 结果图像与分析

![lab4_2_3](E:\cylia\大三\数字图像\lab4\lab4_2_3.png)

幅度（Magnitude）表示了每个频率成分的强度。当仅使用幅度信息进行反变换时，得到的是一个只保留了原图像频谱中各频率分量强度而丢失了其相对位置信息的结果。这种情况下，重构出的图像通常看起来模糊，因为它缺少了决定像素间精确关系的相位信息。

相位（Phase）则包含了关于信号结构的信息，它决定了各个频率分量如何相互作用以形成最终的信号形状。即使没有幅度信息，仅仅依靠相位信息进行反变换也能保留一些关键的结构特征。然而，单独使用相位信息反变换的结果可能缺乏直观的视觉意义，因为缺少了幅度信息提供的强度细节。

从图像来看，人眼对图像的相频特性比幅频特性更敏感。



### 3 共轭后反变换

```matlab
% 傅里叶变换
F1 = fft2(img1);
F2 = fft2(img2);

% 共轭逆变换
% 取共轭
F1_conj = conj(F1);
F2_conj = conj(F2);

% 逆变换
IF1_conj = ifft2(F1_conj);
IF2_conj = ifft2(F2_conj);
```

结果图像：图像倒置

![lab4_4](E:\cylia\大三\数字图像\lab4\lab4_4.png)

<div STYLE="page-break-after: always;"></div>

### 4 低通滤波器

#### 4.1 三种低通滤波器的代码实现

理想低通滤波器 (Ideal Low-Pass Filter, ILPF):

```matlab
function out = ILPF(in, thre) % threshold 阈值
    [r,l,~] = size(in);
    % 傅里叶变换并移动低频
    F = fft2(in);
    f_shift = fftshift(F);
    % 用 meshgrid 从给定的向量创建二维网格坐标矩阵
    [u,v] = meshgrid(-l/2 : l/2-1, -r/2 : r/2-1); 
    % 计算到原点的距离
    dist = hypot(u,v);
    % 滤波器函数 H(u,v) 小于阈值时为 1，大于阈值时为 0
    H = (dist <= thre);
    % 滤波后的图像 (.* 逐元素乘法运算符)
    graph = f_shift .* H;
    % 傅里叶逆变换
    out = abs(ifft2(ifftshift(graph)));
end
```

巴特沃斯低通滤波器(Butterworth Low-Pass Filter, BLPF):

```matlab
function out = BLPF(in, thre, n)
    [r,l,~] = size(in);
    F = fft2(in);
    f_shift = fftshift(F);
    [u,v] = meshgrid(-l/2 : l/2-1, -r/2 : r/2-1); 
    dist = hypot(u,v);
    % 滤波器函数 H(u,v) = 1/(1+(D(u,v)/D0)^2n))
    H = 1 ./ (1 + ((dist ./ thre) .^ (2 * n)));
    graph = f_shift .* H;
    out = abs(ifft2(ifftshift(graph)));
end
```

高斯低通滤波器(Gaussian Low-Pass Filter, GLPF):

```matlab
function out = GLPF(in, thre, n)
    [r,l,~] = size(in);
    F = fft2(in);
    f_shift = fftshift(F);
    [u,v] = meshgrid(-l/2 : l/2-1, -r/2 : r/2-1); 
    dist = hypot(u,v);
    % 滤波器函数 H(u,v) = exp(-(D(u,v)/threshold)^n)
    H = exp(-(dist ./ thre) .^ n);
    graph = f_shift .* H;
    out = abs(ifft2(ifftshift(graph)));
end
```

#### 4.2 对图像 pout.bmp、Girl.bmp 分别采用理想低通滤波器、巴特沃斯低通滤波器和高斯低通滤波器（截止频率自选），再做反变换。

结果图像1（threshold:35	n_BLPF:1	n_GLPF:2）：

![lab4_5_1](E:\cylia\大三\数字图像\lab4\lab4_5_1.png)

结果图像2（threshold:10	n_BLPF:1	n_GLPF:2）：

![lab4_5_2](E:\cylia\大三\数字图像\lab4\lab4_5_2.png)

观察不同截止频率下采用不同低通滤波器得到的图像与原图像的区别：截止频率越低，图像越模糊。

振铃效应：信号的突变点（如边缘）附近出现的震荡或波动。对比图像可以发现，**理想低通滤波器**的振铃效应最为明显，因为它的频率响应特性造成了显著的空间域震荡。**巴特沃斯低通滤波器**根据其阶数的不同会有不同程度的振铃现象，但总体上比理想低通滤波器要好。**高斯低通滤波器**由于其平滑的频率响应，在三种滤波器中引起的振铃效应最小。

#### 4.3 对原始图像 Girl.bmp 分别加椒盐噪声、高斯噪声，产生有噪声图像，利用上述低通滤波器进行去噪

结果图像（threshold:50	n_BLPF:1	n_GLPF:2）：

![lab4_6](E:\cylia\大三\数字图像\lab4\lab4_6.png)

对比去噪效果：对于椒盐噪声，三种低通滤波器的去噪效果均不理想；而对于高斯噪声，三种低通滤波器都能起到一定的作用，对比图像，高斯低通滤波器在处理高斯噪声的降噪效果较好，并较好地保护了图像细节。



### 5 高通滤波器

理想高通滤波器(Ideal High-Pass Filter, IHPF)：

```matlab
function out = IHPF(in, thre)
    [r,l,~] = size(in);
    % 傅里叶变换并移动低频
    F = fft2(in);
    f_shift = fftshift(F);
    % 频率坐标
    [u,v] = meshgrid(-l/2 : l/2-1, -r/2 : r/2-1); 
    % 计算到原点的距离
    dist = hypot(u,v);
    % 滤波器函数 H(u,v) 小于阈值时为 1，大于阈值时为 0
    H = (dist > thre);
    % 滤波后的图像
    graph = f_shift .* H;
    % 傅里叶逆变换
    out = abs(ifft2(ifftshift(graph)));
end
```

巴特沃斯高通滤波器(Butterworth High-Pass Filter, BHPF):

```matlab
function out = BHPF(in, thre, n)
    [r,l,~] = size(in);
    % 傅里叶变换并移动低频
    F = fft2(in);
    f_shift = fftshift(F);
    % 频率坐标
    [u,v] = meshgrid(-l/2 : l/2-1, -r/2 : r/2-1); 
    % 到原点的距离
    dist = hypot(u,v);
    % 滤波器函数 H(u,v) = 1/(1+(D(u,v)/D0)^2n))
    H = 1 ./ (1 + ((thre ./ dist) .^ (2 * n)));
    % 滤波后的图像
    graph = f_shift .* H;
    % 傅里叶逆变换
    out = abs(ifft2(ifftshift(graph)));
end
```

高斯高通滤波器(Gaussian High-Pass Filter, GHPF):

```matlab
function out = GHPF(in, thre, n)
    [r,l,~] = size(in);
    % 傅里叶变换并移动低频
    F = fft2(in);
    f_shift = fftshift(F);
    % 频率坐标
    [u,v] = meshgrid(-l/2 : l/2-1, -r/2 : r/2-1); 
    % 计算到原点的距离
    dist = hypot(u,v);
    % 滤波器函数 H(u,v) = exp(-(D(u,v)/threshold)^n)
    H = exp(-(thre ./ dist) .^ n);
    % 滤波后的图像
    graph = f_shift .* H;
    % 傅里叶逆变换
    out = abs(ifft2(ifftshift(graph)));
end
```

对图像 pout.bmp、Girl.bmp 分别采用高通滤波器、巴特沃斯高通滤波器和高斯高通滤波器，再做反变换:

<div STYLE="page-break-after: always;"></div>

结果图像1（threshold:5	n_BHPF:1	n_GHPF:2）：

![lab4_7_1](E:\cylia\大三\数字图像\lab4\lab4_7_1.png)



结果图像2（threshold:15	n_BHPF:1	n_GHPF:2）：

![lab4_7_2](E:\cylia\大三\数字图像\lab4\lab4_7_2.png)

<div STYLE="page-break-after: always;"></div>

结果图像3（threshold:35	n_BHPF:1	n_GHPF:2）：

![lab4_7_3](E:\cylia\大三\数字图像\lab4\lab4_7_3.png)

不同截止频率下采用不同高通滤波器得到的图像与原图像的区别：截止频率越低，图像轮廓越明显；截止频率越高，图像轮廓越模糊。

振铃效应：通低通滤波器，理想高通滤波器的振铃效应最为明显；巴特沃斯高通滤波器有一定的振铃现象，但比理想高通滤波器要好；高斯高通滤波器，在三种滤波器中引起的振铃效应最小。

<div STYLE="page-break-after: always;"></div>

### 6 高频增强滤波

理想高频增强滤波器(Ideal High-frequency Filter, IHFF)：

```matlab
function out = IHFF(in, thre, a, b)
    [r,l,~] = size(in);
    F = fft2(in);
    f_shift = fftshift(F);
    [u,v] = meshgrid(-l/2 : l/2-1, -r/2 : r/2-1); 
    dist = hypot(u,v);
    H = (dist > thre);
    H = a * H + b; % 高频增强
    graph = f_shift .* H;
    out = abs(ifft2(ifftshift(graph)));
end
```

巴特沃斯高频滤波器(Butterworth High-frequency Filter, BHPF):

```matlab
function out = BHFF(in, thre, n, a, b)
    [r,l,~] = size(in);
    F = fft2(in);
    f_shift = fftshift(F);
    [u,v] = meshgrid(-l/2 : l/2-1, -r/2 : r/2-1); 
    dist = hypot(u,v);
    H = 1 ./ (1 + ((thre ./ dist) .^ (2 * n)));
    H = a * H + b; % 高频增强
    graph = f_shift .* H;
    out = abs(ifft2(ifftshift(graph)));
end
```

高斯高频滤波器(Gaussian High-frequency Filter, GHPF):

```matlab
function out = GHFF(in, thre, n, a, b)
    [r,l,~] = size(in);
    F = fft2(in);
    f_shift = fftshift(F);
    [u,v] = meshgrid(-l/2 : l/2-1, -r/2 : r/2-1); 
    dist = hypot(u,v);
    H = exp(-(thre ./ dist) .^ n);
    H = a * H + b; % 高频增强
    graph = f_shift .* H;
    out = abs(ifft2(ifftshift(graph)));
end
```

<div STYLE="page-break-after: always;"></div>

对图像 pout.bmp 经过高频增强滤波，再进行直方图均衡化，显示结果图像； 对图像 pout.bmp 先进行直方图均衡化，再经过高频增强滤波，显示结果图像（threshold:15	n_BHFF:1	n_EHFF:1	a:4	b:1）：

![lab4_8](E:\cylia\大三\数字图像\lab4\lab4_8.png)

观察对比不同处理顺序对结果图像的影响：

先高频增强滤波，再进行直方图均衡化：有更明显的边缘和细节，图像的视觉效果较好，但出现有过度曝光和细节丢失的现象。

先进行直方图均衡化，再经过高频增强滤波改善图像的对比度，但视觉效果不如上图。

<div STYLE="page-break-after: always;"></div>

## Lab5 图像恢复与图像分割

### 1 图像恢复

对图像 flower1.jpg 设置运动位移 30 个像素、运动方向 45 度，产生运动模糊图像:

```matlab
blur_filter = fspecial("motion", 30, 45);
motion_img = imfilter(im2double(img), blur_filter, 'conv', 'circular');
```

对其采用逆滤波和维纳滤波进行恢复:

```matlab
% 采用逆滤波进行恢复 Inverse Filtering
if_img = deconvwnr(motion_img, blur_filter);
% 采用维纳滤波进行恢复 Wiener Filtering (无噪声)
wf_img = deconvwnr(motion_img, blur_filter);
```

对产生的运动模糊图像加高斯噪声(均值:0 标准差:0.0001)，产生有噪声图像:

```matlab
noisy = imnoise(motion_img, 'gaussian', 0, 0.0001);
```

分别对其采用逆滤波和维纳滤波进行恢复:

```matlab
% 逆滤波
if_gimg = deconvwnr(noisy, blur_filter);
% 维纳滤波
wf_gimg = deconvwnr(noisy, blur_filter, 0.0001);
```

结果图像：

![lab5_1](E:\cylia\大三\数字图像\lab5\lab5_1.png)

结果分析：

- **无噪声情况**：维纳滤波与逆滤波恢复结果相同，能够提供清晰的图像。
- **有噪声情况**：维纳滤波的优势更加明显，它不仅能够有效恢复图像细节，还能较好地抑制噪声，而逆滤波则因为对噪声过于敏感，导致恢复效果极差。



### 2 图像分割

大津法（OTSU）：

#### 2.1 调用函数

```matlab
G = graythresh(img);
```

#### 2.2 手动实现：

数学原理：

1. 统计灰度级中每个像素在整幅图像中的个数。

   ```matlab
   [M, N] = size(img);
   total_pixels = M * N;
   hist_counts = zeros(1, 256);
   for i = 0:255
       hist_counts(i+1) = sum(img(:) == i); % 统计每个灰度级出现次数
   end
   ```

2. 计算每个像素在整幅图像的概率分布。

   ```matlab
   prob = hist_counts / total_pixels;
   ```

3. 对灰度级进行遍历搜索，计算当前灰度值下前景背景类间概率。

   ```matlab
   omega_0 = zeros(1, 256); % 累积概率
   omega_1 = zeros(1, 256);
   mu_0 = zeros(1, 256); % 累积均值
   mu_1 = zeros(1, 256);
   for t = 0:255
       omega_0(t+1) = sum(prob(1:t+1));   % 前景累计概率 w0
       omega_1(t+1) = sum(prob(t+2:256));
       mu_0(t+1) = sum((0:t).*prob(1:t+1)); % 前景累计均值 mu0
       mu_1(t+1) = sum((t+1:255).*prob(t+2:256));
   end
   ```

4. 通过目标函数计算出类内与类间方差下对应的阈值。

对于图像 $I(x,y)$，前景（即目标）和背景的分割阈值记作 $T$，属于前景的像素点数占整幅图像的比例记为 $\omega0$，其平均灰度 $\mu0$；背景像素点数占整幅图像的比例为 $\omega1$，其平均灰度为 $\mu1$。图像的总平均灰度记为 $\mu$，类间方差记为 $g$。

假设图像的背景较暗，并且图像的大小为 $M×N$，图像中像素的灰度值小于阈值 $T$ 的像素个数记作 $N0$，像素灰度大于阈值 $T$ 的像素个数记作 $N1$，则有：

$\omega0 = N0 / (M×N) \tag1$                        (1)

$\omega1 = N1 / (M×N)$                        (2)

$N0 + N1 = M×N$                       (3)

$\omega0 + \omega1 = 1$                                   (4)

$\mu = \omega0 * \mu0 + \omega1 * \mu1$                (5)

$g =  \omega0 * (\mu0 - \mu)^2 + \omega1 * (\mu1 - \mu)^2$  (6)

将式(5)代入式(6)，得到等价公式： $g = \omega0 *\omega1 * (\mu0 - \mu1)^2$  (7)

采用遍历的方法可以得到类间方差最大的阈值 $T$。

```matlab
mu = mu_0(end);
g_0 = zeros(1, 256); % 类间方差 
g_1 = zeros(1, 256);
max_id = 0;
max_sum = 0;
for t = 0:255
    if omega_0(t+1) == 0 || omega_1(t+1) == 0
        g_0(t+1) = 0; % 跳过无效情况
        continue;
    end
    mu0 = mu_0(t+1);
    mu1 = mu_1(t+1);
    w0 = omega_0(t+1);
    w1 = omega_1(t+1);
    % mu1 = (global_mean - omega_0(t+1)*mu0) / (1 - omega_0(t+1));
    g_0(t+1) = w0 * (mu0 - mu)^2 + w1 * (mu1 - mu)^2;
    % g = w0 * w1 * (mu0 - mu1)^2
    g_1(t+1) = w0 * w1 * (mu0 - mu1)^2;
end
```

结果图像：

![lab5_2](E:\cylia\大三\数字图像\lab5\lab5_2.png)




### 3 分裂合并算法

首先使用四叉树对图像进行分割：

```matlab
% 四叉树分割 2: 最小块边长 (mindim) 
qtree = qtdecomp(img, threshold, 2);
block = zeros(size(qtree));

% 可视化四叉树分割的结果（白线标注）
for dim = [256 128 64 32 16 8 4 2]
    % 计算当前dim在图像中的数量
    numblocks = length(find(qtree == dim));
    if(numblocks > 0)
        % 创建创建边框模板 values 大小为 dim x dim x numblocks
        values = repmat(uint8(1), [dim dim numblocks]);
        values(2:dim, 2:dim, :) = 0;
        % 插入边框
        block = qtsetblk(block,qtree,dim,values);
    end
end
```

接着为区域分割得到每个块进行标记：

```matlab
tag = 0;
for dim = [64 32 16 8 4 2]
    % 找到 dim x dim 块在图形中的位置
    % val：包含所有符合条件的块的数据，形状为 [dim, dim, n]
    [val, r , c] = qtgetblk(img, qtree, dim); 
    if ~isempty(val) % val 非空
        for i = 1 : length(r) % length(r) 当前尺寸下块的数量
            tag = tag + 1;
            block(r(i):r(i) + dim - 1, c(i): c(i) + dim - 1) = tag; 
        end
    end
end
```

然后合并极差较小的块：

```matlab
for i = 1 : tag
    bound = boundarymask(block==i, 4) & (~(block == i));
    % 查找边界掩码中值为 1 的像素点的行列坐标
    [r, l] = find(bound == 1);
    for k = 1 : size(r,1)
        % 将相邻分块的像素值合并到一个数组中
        merge = img((block == i) | (block == block(r(k), l(k))));
        % 计算合并后像素的极差是否小于阈值
        if (range(merge(:)) < threshold * 256)
            block(block == block(r(k), l(k))) = i;
        end
    end
end
```

最后检测并标记图像中不同区域之间的边界：

```matlab
ans2 = img;
for tag = 1 : 255
    for i = 1 : 255
        % 如果当前像素点处于两个不同的分块的边界上
        if (block(tag, i) ~= block(tag, i + 1) || block(tag, i) ~= block(tag + 1, i))
            ans2(tag, i) = 255; % 设置边界为白色
        end
    end
end
```

结果图像（threshold = 0.35）：

![lab5_3](E:\cylia\大三\数字图像\lab5\lab5_3.png)
